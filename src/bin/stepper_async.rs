//! Simple demo periodically rotating a stepper motor via ESP32C3 & DRV8825
//!
//! Connections List (TODO: wiring schematic)
//! - GPIO20: stepper (DRV8825 DIR)
//! - GPIO21: stepper (DRV8825 STEP)
//!
//! Example is written assuming the DRV8825 board is configured per MICRO_STEP_MODE_DIVISOR value
//! e.g. MICRO_STEP_MODE_DIVISOR = 8 -> 1/8th step mode

#![no_std]
#![no_main]
#![feature(impl_trait_in_assoc_type)]

use defmt::info;
use embassy_executor::Spawner;
use embassy_time::{Duration, Instant, Ticker, Timer};
use esp_hal::{
    gpio::{AnyPin, Level, Output, OutputConfig},
    interrupt::{Priority, software::SoftwareInterruptControl},
    timer::{AnyTimer, timg::TimerGroup},
};
use esp_hal_embassy::InterruptExecutor;
use static_cell::StaticCell;
use {defmt_rtt as _, esp_backtrace as _};

// Inputs
const MOTOR_STEPS_PER_REV: u32 = 200;
const MICRO_STEP_MODE_DIVISOR: u32 = 2;
const RPM: u32 = 320;
const NUM_REVS: u32 = 16;
const PAUSE_SEC: u32 = 2;
const SAMPLE_INTERVAL: u32 = 100;

// Calculated values
const NUM_STEPS: u32 = NUM_REVS * MOTOR_STEPS_PER_REV * MICRO_STEP_MODE_DIVISOR;
const LOG_SAMPLES: u32 = NUM_STEPS / SAMPLE_INTERVAL;
const DELAY_TIME_US: u32 =
    60 * 1_000_000 / (2 * RPM * MOTOR_STEPS_PER_REV * MICRO_STEP_MODE_DIVISOR);
const STEP_TIME_US: u32 = DELAY_TIME_US * 2;
const RUN_TIME_US: u32 = NUM_STEPS * STEP_TIME_US;
const TOTAL_CYCLE_TIME_US: u32 = RUN_TIME_US + PAUSE_SEC * 1_000_000;

#[esp_hal_embassy::main]
async fn main(_spawner: Spawner) {
    // Initialize hardware
    let peripherals = esp_hal::init(esp_hal::Config::default());
    let sw_ints = SoftwareInterruptControl::new(peripherals.SW_INTERRUPT);

    // Initialize embassy
    let timg0 = TimerGroup::new(peripherals.TIMG0);
    let timg1 = TimerGroup::new(peripherals.TIMG1);
    let timer0: AnyTimer = timg0.timer0.into();
    let timer1: AnyTimer = timg1.timer0.into();
    esp_hal_embassy::init([timer0, timer1]);

    // Initialize higher priority executor for managing PWM signal.
    // This allows the time-sensitive signal output to interrupt lower-priority tasks
    // run on the normal-priority (thread-mode) executor generated by the
    // esp-hal-embassy::main macro ("_spawner").
    // This is shown for reference only, since there are no other tasks in this case.
    static EXECUTOR: StaticCell<InterruptExecutor<2>> = StaticCell::new();
    let executor = InterruptExecutor::new(sw_ints.software_interrupt2);
    let executor = EXECUTOR.init(executor);
    let spawner = executor.start(Priority::Priority3);
    spawner.must_spawn(pwm_manager(
        peripherals.GPIO20.into(),
        peripherals.GPIO21.into(),
    ));
}

/// Task to manage PWM output signal to DRV8825 driver
#[embassy_executor::task]
async fn pwm_manager(dir_pin: AnyPin<'static>, step_pin: AnyPin<'static>) {
    info!("delay time (us): {}", DELAY_TIME_US);
    info!("cycle time (us): {}", RUN_TIME_US);
    info!("total cycle time (us): {}", TOTAL_CYCLE_TIME_US);
    info!("log samples (us): {}", LOG_SAMPLES);

    // Initial delay to prevent initialization issues
    Timer::after_millis(100).await;

    // Initialize motor control GPIO
    let output_config = OutputConfig::default();
    let mut _dir = Output::new(dir_pin, Level::High, output_config);
    let mut step = Output::new(step_pin, Level::Low, output_config);

    // for logging key times
    let mut high_start_times = [Instant::from_micros(0); LOG_SAMPLES as usize];
    let mut low_start_times = [Instant::from_micros(0); LOG_SAMPLES as usize];
    let mut end_cycle_times = [Instant::from_micros(0); LOG_SAMPLES as usize];

    // start cycle
    let overall_time = Instant::now();
    let mut cycle_ticker = Ticker::every(Duration::from_micros(TOTAL_CYCLE_TIME_US.into()));

    // Event loop
    loop {
        // get time at the start of this rotation
        let initial_time = Instant::now();
        let mut ticker = Ticker::every(Duration::from_micros(DELAY_TIME_US.into()));

        // perform 1 rotation
        for i in 0..NUM_STEPS as usize {
            let is_sample = i % SAMPLE_INTERVAL as usize == 0;
            let log_index = i / SAMPLE_INTERVAL as usize;

            step.set_high();
            if is_sample {
                high_start_times[log_index] = Instant::now();
            };
            ticker.next().await;

            step.set_low();
            if is_sample {
                low_start_times[log_index] = Instant::now();
            };
            ticker.next().await;

            if is_sample {
                end_cycle_times[log_index] = Instant::now();
            };
        }

        // log out timing data
        for i in 0..LOG_SAMPLES as usize {
            let high_start_time = high_start_times[i];
            let low_start_time = low_start_times[i];
            let end_cycle_time = end_cycle_times[i];

            let high_time = low_start_time.duration_since(high_start_time).as_micros();
            let low_time = end_cycle_time.duration_since(low_start_time).as_micros();
            let total_cycle_time = end_cycle_time.duration_since(high_start_time).as_micros();
            let total_elapsed = end_cycle_time.duration_since(initial_time).as_millis();
            let overall_elapsed = end_cycle_time.duration_since(overall_time).as_secs();
            info!(
                "step {}: {} - {} - {} - {} - {}",
                i, high_time, low_time, total_cycle_time, total_elapsed, overall_elapsed
            );
        }

        // wait until "pause" period ends
        cycle_ticker.next().await;
    }
}
